Mimo, i¿ dane s¹ na bie¿¹co wysy³ane do zdalnego interfejsu u¿ytkownika, trzeba wzi¹æ pod uwagê awaryjnoœæ takiego przesy³u oraz mo¿liwoœæ gubienia pakietów danych przy du¿ych odleg³oœciach. Potrzebny jest stabilny i szybki system zapisu zebranych danych, który bêdzie niezale¿ny od bezprzewodowej komunikacji. Wybrano zapis danych na kartê SD pod³¹czon¹ bezpoœrednio do g³ównego komputera pok³adowego. Standard kart SD jest standardem opracowanym przez trzech producentów: Toshiba, SanDisk i MEI~\cite{manual:sandisk}, który wyewoluowa³ ze starszego standardu MultiMediaCard ($MMC$). Zarówno budowa samej karty, po³¹czenia elektryczne jak i protokó³ s¹ czêœci¹ specyfikacji Secure Digital Card ($SDC$), podzielonej na wiele mniejszych dokumentów~\cite{spec:sd}\cite{spec:sdio}. $SDC$ oferuje zaawansowany interfejs 9 linii elektrycznych (zegarowej, komend, 4 linie danych i 3 linie zasilania), który mo¿e pracowaæ z maksymaln¹ czêstotliwoœci¹ 50~MHz~\cite{spec:sd} (\hyperref[fig:sd]{Rysunek~\ref*{fig:sd}}). Popularnie urz¹dzenia spe³niaj¹ce wymogi specyfikacji $SDC$ nazywa siê kartami SD.

\begin{figure}[h]
\centering \includegraphics[width=0.3\linewidth]{figures/SD_diagram1.JPG}
\caption{Schemat wyprowadzeñ $SDC$} \label{fig:sd}
\end{figure}

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|l|l|l|}
	\hline 
  	\cellcolor{gray!50} \textbf{Pin} & \cellcolor{gray!50} \textbf{Nazwa} & \cellcolor{gray!50} \textbf{Funkcja (SD Bus)} & \cellcolor{gray!50} \textbf{Funkcja (SPI)}\\
 	 \hline \hline
 	  \textbf{1}& DAT3/CS & Linia danych 3 & Chip Select/Slave Select\\
 	 \hline
 	  \textbf{2}& CMD/DI & Linia komend & Master Output Slave Input (MOSI)\\
 	 \hline
 	  \textbf{3}& VSS1 & Masa & Masa\\
 	 \hline
 	  \textbf{4}& VDD & Napiêcie zasilaj¹ce & Napiêcie zasilaj¹ce\\
 	 \hline
 	  \textbf{5}& CLK & Linia zegarowa & Linia zegarowa (SCK)\\
 	 \hline
 	  \textbf{6}& VSS2 & Masa & Masa\\
 	 \hline
 	  \textbf{7}& DAT0/DO & Linia danych 0 & Master Input Slave Output (MISO)\\
  	\hline
  	 \textbf{8}& DAT1/NC & Linia danych 1 & Niepod³¹czony\\
  	\hline 
  	 \textbf{9}& DAT2/NC & Linia danych 2 & Niepod³¹czony\\
  	\hline
	\end{tabular} 
	\caption{Opis wyprowadzeñ karty SD}\label{tab:sd}
	\end{center}
	\end{table}
	
Z \hyperref[tab:sd]{Tabeli~\ref*{tab:sd}} wynika, ¿e karty SD wspieraj¹ dwa fizyczne protoko³y komunikacyjne: $SD$ $Bus$ (\hyperref[sec:sub:sdbus]{Sekcja~\ref*{sec:sub:sdbus}: SD Bus}) oraz $SPI$ (\hyperref[sec:sub:spi]{Sekcja~\ref*{sec:sub:spi}: Serial Peripheral Interface}).\\

Protokó³ komunikacyjny $SDC$ opiera siê na prostym systemie komend i odpowiedzi. Wszystkie komendy s¹ inicjowane przez mastera. Karta odpowiada na zapytanie ramk¹ odpowiedzi, po której mo¿e nast¹piæ przesy³ danych, je¿eli taka by³a komenda, lub zg³oszenie b³êdu. Ca³y protokó³ s³u¿y do obs³ugi systemu plików zawartego na karcie. 

\subsection{FatFs} \label{sec:sub:fat}
Z perspektywy systemu plików ka¿dy noœnik danych podzielony jest na klastry i sektory. Sektory s¹ zazwyczaj d³ugoœci 512 bajtów, natomiast klastry przyjmuj¹ ró¿ne wartoœci, w zale¿noœci od pojemnoœci dysku i rodzaju systemu plików. Pliki zapisywane s¹ w klastrach, zajmuj¹c je ca³kowicie. Oznacza to, ¿e gdy plik jest mniejszy od pojedynczego klastra, ca³y klaster zostanie przypisany do tego pliku. System plików $FAT$ opiera siê na tablicy alokacji plików (File Allocation Table). Jest to tablica, która stanowi katalog plików znajduj¹cych siê na danej partycji/dysku~\cite{book:paprocki}.\\ 

$FatFs$ to biblioteka implementuj¹ca system plików $FAT$ dla systemów wbudowanych. Jest to pomost ³¹cz¹cy warstwê sprzêtow¹ z warstw¹ aplikacji. Niezale¿nie od platformy sprzêtowej, po zdefiniowaniu podstawowych funkcji, system zadzia³a na wybranej platformie sprzêtowej. Minimalna aplikacja zak³ada, ¿e u¿ytkownik napisze funkcje odpowiedzialne za wys³anie i odbiór wiadomoœci oraz inicjalizacjê karty. Dok³adny opis przewidywanego dzia³ania tych funkcji dostêpny jest na g³ównej stronie, z której pobrano bibliotekê~\cite{misc:fat}. Dodatkowo na stronie podane s¹ Ÿród³a, z których mo¿na pobraæ biblioteki oparte na $FatFs$ implementuj¹ce j¹ na wybranych platformach sprzêtowych. Jedn¹ z takich bibliotek, autorstwa Tilen'a Majerle~\cite{lib:sd}, u¿yto w projekcie.\\

\subsection{SD Bus} \label{sec:sub:sdbus}
Protokó³ $SD$ $Bus$ dzieli siê na dwie wersje. Wyró¿nia siê wersjê 1-bitow¹ oraz 4-bitow¹:
\begin{itemize}
\item $SD$ $Bus$ w wersji 1-bitowej to synchroniczny, szeregowy protokó³ z jedn¹ lini¹ komend, jedn¹ danych i jedn¹ zegarow¹.
\item $SD$ $Bus$ w wersji 4-bitowej ró¿ni siê od niego tylko szerokoœci¹ linii danych, których jest 4. Przy dobrej implementacji mo¿e byæ czterokrotnie szybszy ni¿ jego ubo¿sza wersja.
\end{itemize}

Protokó³ $SD$ $Bus$ wymaga obliczania cyklicznego kodu nadmiarowego $CRC$ (Cyclic Redundancy Check), który zapobiega b³êdom transmisji. W przypadku wersji 4-bitowej, $CRC$ liczone jest dla ka¿dej linii danych z osobna. $SD$ $Bus$ jest domyœlnym protoko³em do obs³ugi kart SD, aby prze³¹czyæ kartê w tryb $SPI$ nale¿y podczas inicjalizacj u¿yæ specjalnej komendy i przekazaæ odpowiedni dla niej kod $CRC$~\cite{spec:sd}.

\subsection{Serial Peripheral Interface} \label{sec:sub:spi}
Serial Peripheral Interface ($SPI$) s³u¿y do dwukierunkowej (full duplex), synchronicznej, szeregowej komunikacji i sk³ada siê z trzech linii:
\begin{itemize}
\item $MISO$ - Master Input Slave Output, jednokierunkowa linia danych s³u¿¹ca do odbierania danych przez mastera.
\item $MOSI$ - Master Output Slave Input, jednokierunkowa linia danych s³u¿¹ca do wysy³ania danych przez mastera.
\item $SCK$ - Serial Clock, linia zegarowa s³u¿¹ca synchronizacji komunikacji~\cite{book:paprocki}.
\end{itemize}
Do aktywacji wybranego uk³adu peryferyjnego s³u¿y dodatkowo linia $SS$ (Slave Select - wybór uk³adu podrzêdnego).\\

Jako ¿e podstaw¹ komunikacji z kartami SD jest wymiana komend i danych, a $SPI$ nie dysponuje lini¹ komend, wszystkie komendy i dane s¹ szeregowo wysy³ane na linii $MOSI$ i odbierane na linii $MISO$. Tryb $SPI$ wspiera wiêkszoœæ komend u¿ywanych w komunikacji z kartami SD. Implementacja tego protoko³u jest du¿o ³atwiejsza ni¿ specyficznego $SD$ $Bus$, dlatego jest to popularniejsze rozwi¹zanie i zdecydowanie lepiej udokumentowane. Wiêkszoœæ dzisiejszych mikrokontrolerów posiada konfigurowalne peryferium $SPI$. W przypadku jego braku, mo¿na ³atwo zaimplementowaæ komunikacjê na zwyk³ych wyjœciach cyfrowych~\cite{spec:sd}.

\subsection{Direct Memory Access} \label{sec:sub:dma}
Bardzo wiele operacji wykonywanych na blokach danych polega tylko na ich kopiowaniu. Nie ma potrzeby anga¿owaæ do tego procesu rejestrów procesora. Na potrzeby kopiowania danych bez u¿ycia procesora, stworzono blok Direct Memory Acces ($DMA$). Je¿eli rozpatrywaæ peryferia jako zmapowan¹ pamiêæ, mo¿na u¿ywaæ $DMA$ do kopiowania danych z peryferiów do bloków pamiêci wewnêtrznej lub odwrotnie. Obs³uga karty SD mo¿e odbywaæ siê przy u¿yciu modu³u $DMA$, dziêki czemu mo¿na wskazaæ kontrolerowi $DMA$ blok pamiêci, który ma zostaæ skopiowany do karty, a zapis odbêdzie siê bez u¿ycia zasobów procesora.
